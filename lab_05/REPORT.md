# Лабораторная работа 5: *обработка очередей*

**Цель работы:** отработка навыков работы с типом данных «очередь», представленным в виде одномерного массива и односвязного линейного списка. Сравнительный анализ реализации алгоритмов включения и исключения элементов из очереди при использовании двух указанных структур данных. Оценка эффективности программы (при различной реализации) по времени и по используемому объему памяти.

## Задание (Вариант 1)

Система массового обслуживания состоит из обслуживающего аппарата (ОА) и очереди заявок двух типов.

Заявки 1-го типа поступают в "хвост" очереди по случайному закону с интервалом времени Т1, равномерно распределенным от 0 до 5 единиц времени (е.в.). В ОА они поступают из "головы" очереди по одной и обслуживаются также равновероятно за время Т2 от 0 до 4 е.в., после чего покидают систему.
Единственная заявка 2-го типа постоянно обращается в системе, обслуживаясь в ОА равновероятно за время Т3 от 0 до 4 е.в. и возвращаясь в очередь не далее 4-й позиции от "головы". В начале процесса заявка 2-го типа входит в ОА, оставляя пустую очередь. (Все времена – вещественного типа)

Смоделировать процесс обслуживания первых 1000 заявок 1-го типа. Выдавать после обслуживания каждых 100 заявок 1-го типа информацию о текущей и средней длине очереди, количестве вошедших и вышедших заявок и о среднем времени пребывания заявок в очереди. В конце процесса выдать общее время моделирования, время простоя аппарата, количество вошедших в систему и вышедших из нее заявок первого типа и количество обращений заявок второго типа. По требованию пользователя выдать на экран адреса элементов очереди при удалении и добавлении элементов. Проследить, возникает ли при этом фрагментация памяти.

## Использованные структуры

### Односвязный список

```cpp
template <class T>
struct my_list
{
    T data;              // Данные
    my_list<T> *next;    // Следующий элемент
};
```

### Реализация очереди массивом

```cpp
template <class T>
struct queue_array
{
    T data[SIZE];         // Массив с данными
    T *pin;               // Хвост
    T *pout;              // Голова
    int count;            // Количество элементов в очереди

    queue_array();        // Конструктор
    void add(T data_el);  // Добавление в очередь
    void pop();           // Удаление из очереди
    int size();           // Получить длину очереди
    T take_head();        // Получить элемент из головы очереди
};
```

### Реализиция очереди списком

```cpp
template <class T>
struct queue_list
{
    my_list<T> *pin;      // Хвост
    my_list<T> *pout;     // Голова
    int count;            // Количество элементов в очереди

    queue_list();         // Конструктор
    void add(T data);     // Добавление в очередь
    void pop();           // Удаление из очереди
    int size();           // Получить длину очереди
    T take_head();        // Получить элемент из головы очереди
    void free_list();     // Очистка листа
};
```

## Тесты

### Негативные тесты

1. **Некорректный ввод**

	```
	Выводить адреса памяти? (фрагментация)
	[1] - Да
	[2] - Нет
	>asd
	>sdf
	>g
	>dfg
	>dgsdf
	>231
	>34
	>3
	>5
	>4
	>1
	```
	
### Позитивные тесты

1. **Автоматический ввод времени**

	```
	Реализицая:
	[1] - Массивом
	[2] - Списком
	>2
	
	Ввести максимальное T1, T2, T3?
	[1] - Использовать стандартные (5, 4, 4)
	[2] - Ввести
	>1
	
	Выводить адреса памяти? (фрагментация)
	[1] - Да
	[2] - Нет
	>2
	
	Реализация списком:
	Время: 296.155
	Количество обработанных заявок: 100
	Текущая длина очереди: 6
	Средняя длина очереди: 4.62926
	Количество вошедших заявок: 107
	Количество вышедших заявок: 100
	Среднее время пребывания заявок в очереди: 15.88
	
	Время: 593.316
	Количество обработанных заявок: 200
	Текущая длина очереди: 23
	Средняя длина очереди: 9.67484
	Количество вошедших заявок: 224
	Количество вышедших заявок: 200
	Среднее время пребывания заявок в очереди: 28.01
	
	Время: 870.116
	Количество обработанных заявок: 300
	Текущая длина очереди: 35
	Средняя длина очереди: 15.3604
	Количество вошедших заявок: 336
	Количество вышедших заявок: 300
	Среднее время пребывания заявок в очереди: 41.5633
	
	Время: 1140.17
	Количество обработанных заявок: 400
	Текущая длина очереди: 47
	Средняя длина очереди: 21.2544
	Количество вошедших заявок: 448
	Количество вышедших заявок: 400
	Среднее время пребывания заявок в очереди: 54.85
	
	Время: 1405.14
	Количество обработанных заявок: 500
	Текущая длина очереди: 54
	Средняя длина очереди: 26.6757
	Количество вошедших заявок: 555
	Количество вышедших заявок: 500
	Среднее время пребывания заявок в очереди: 69.33
	
	Время: 1702.58
	Количество обработанных заявок: 600
	Текущая длина очереди: 84
	Средняя длина очереди: 33.934
	Количество вошедших заявок: 685
	Количество вышедших заявок: 600
	Среднее время пребывания заявок в очереди: 84.2533
	
	Время: 1936.58
	Количество обработанных заявок: 700
	Текущая длина очереди: 89
	Средняя длина очереди: 40.1441
	Количество вошедших заявок: 790
	Количество вышедших заявок: 700
	Среднее время пребывания заявок в очереди: 99.19
	
	Время: 2216.1
	Количество обработанных заявок: 800
	Текущая длина очереди: 102
	Средняя длина очереди: 47.2276
	Количество вошедших заявок: 903
	Количество вышедших заявок: 800
	Среднее время пребывания заявок в очереди: 113.784
	
	Время: 2490.28
	Количество обработанных заявок: 900
	Текущая длина очереди: 110
	Средняя длина очереди: 54.2272
	Количество вошедших заявок: 1011
	Количество вышедших заявок: 900
	Среднее время пребывания заявок в очереди: 131.968
	
	Время: 2774.28
	Количество обработанных заявок: 1000
	Текущая длина очереди: 119
	Средняя длина очереди: 60.9379
	Количество вошедших заявок: 1120
	Количество вышедших заявок: 1000
	Среднее время пребывания заявок в очереди: 148.818
	
	Общее время моделирования: 2774.28
	Время простоя аппарата: 0.690276
	Количество вошедших заявок первого типа: 1120
	Количество вышедших заявок первого типа: 1000
	Количество обращений заявок второго типа: 409
	
	Сравнение 1000 добавлений и удалений:
	Реализация массивом: 58311 тиков
	Реализация списком: 491391 тиков
	```
	
2. **Ручной вводи времени**

	```
	Выводить адреса памяти? (фрагментация)
	[1] - Да
	[2] - Нет
	>2
	
	Реализицая:
	[1] - Массивом
	[2] - Списком
	>1
	
	Ввести максимальное T1, T2, T3?
	[1] - Использовать стандартные (5, 4, 4)
	[2] - Ввести
	>2
	T1: 3
	T2: 2
	T3: 1
	Реализация массивом:
	...
	```

## Сравнение реализиций

### Время 1000 добавлений и удалений

|Реализация массивом|Реализация списком|Эффективность|
|---|---|---|
|48807 тиков|392127 тиков|90%|

### Память

|Количество элементов|Реализация массивом (байт)|Реализация списком (байт)|Эффективность|
|---|---|---|---|
|100|40000|1200|97%|
|1000|40000|12000|45%|
|10000|40000|120000|-200%|

## Контрольные вопросы

1. **Что такое очередь?**<br>Очередь - это струтура данных, в которой элемент добавляется в конец, а удаляется в начале.<br><br>
2. **Каким образом, и какой объем памяти выделяется под хранение очереди при различной ее реализации?**<br>При реализации очереди с помощью массива память выделяется под максимальное количетво элементов, а при реализации с помощью списка выделяется для каждого элемента отдельна при его добавлении.<br><br>
3. **Каким образом освобождается память при удалении элемента из очереди при ее различной реализации?**<br>При реализации массивом, память не освобождается, просто передвигается указатель хвоста по массиву. При реализации списком удаляемяй элемент очищается.<br><br>
4. **Что происходит с элементами очереди при ее просмотре?**<br>При просмотре элеманты удаляются из очереди и добавляются в конец.<br><br>
5. **Каким образом эффективнее реализовывать очередь. От чего это зависит?**<br>По памяти эффективней использовать реализацию списком, так как память выделяется динамически, а реализация массивом занимает максимальное количество памяти. По времени лучше использовать массив, так как время на выделение памяти для каждого элемента не тратится.<br><br>
8. **Что такое фрагментация памяти?**<br>Фрагментация памяти - это когда ячейки освобожденно и занятой памяти чередуются.<br><br>
9. **На что необходимо обратить внимание при тестировании программы?**<br>На общее время моделирования и количество вошедших заявок.<br><br>
10. **Каким образом физически выделяется и освобождается память при
динамических запросах?**<br>При выделении находится свободное место в памяти и туда помещаются данные. При удалении из ячеек памяти удаляются все данные.<br><br>

## Вывод

При реализации очереди массивом память выделяется на максимальное количество элементов за счет чего появляется выйгрыш по времени у реализации списком, так как не происходит выделение памяти на кажный элемент. Но если мы не знаем заранее количество элементов, то происходит проигрыш по памяти при небольшом количестве элементов. Если необходимо обрабатывать очень много элементов, то реализация списком имеет ограничение только оперативной памятью, а массивом ограничивается размером самого массива.