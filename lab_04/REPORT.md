# Лабораторная работа 4: Работа со стеком

**Цель работы:** реализовать операции работы со стеком, который представлен в виде динамического массива и в виде односвязного списка, оценить преимущества и недостатки каждой реализации, получить представление о механизмах выделения и освобождения памяти при работе с динамическими структурами данных.

## Условие задачи (Вариант 8)

Используя операции со стеком реализовать поиск пути в лабиринте, который представлен матрицей.

**Входные данные:** лабиринт в виде матрицы, координаты входа и выхода

**Выходные данные:** лабиринт с найденным путем от входа до выхода

## Используемые структуры

### Координаты ячейки

```cpp
struct coord
{
    int x;                               // Координата x
    int y;                               // Координата y
};
```

### Односвязный список

```cpp
template <class T>
struct my_list
{
    T data;                              // Элемент списка
    my_list<T> *prev;                    // Предыдущий элемент
};
```

### Стек, представленный списком

```cpp
template <class T>
struct stack_list
{
    my_list<T> *element;                  // Последний элемент стека

    stack_list();                         // Конструктор
    bool empty();                         // Проверка на заполненность
    void push(T el);                      // Добавить элемент
    void pop();                           // Удалить верхний элемент
    T take();                             // Получить верхний элемент
    void free_list()                      // Очистка памяти
};

```

### Стек, представленный массивом

```cpp
template <class T>
struct stack_vector
{
    int element;                          // Индекс вурхнего элемента
    T vec[STACK_SIZE];                    // Массив с данными

    stack_vector();                       // Конструктор
    bool empty();                         // Проверка на заполненность
    void push(T el);                      // Добавить элемент
    void pop();                           // Удалить верхний элемент
    T take();                             // Получить верхний элемент
};
```

## Тесты

### Негативные тесты

1. Некорректные данные

	```
	Введите размерность: asd
	Некорректный ввод!
	```

2. Некорректная размерность

	```
	Введите размерность: -3 2
	Некорректный ввод!
	```

3. Некорректные координаты

	```
	Введите размерность: 2 2
	Введите матрицу в обычном виде (1 - стенка, 0 - проход)
	0 0
	0 0
	Введите стартовую позицию: 3 3
	Некорректный ввод!
	```

4. Одна из позиций попала на стенку

	```
	Введите размерность: 2 2
	Введите матрицу в обычном виде (1 - стенка, 0 - проход)
	1 0
	0 0
	Введите стартовую позицию: 0 0
	Введите финишную позицию: 1 1
	Некорректный ввод!
	```

### Позитивные тесты

1. Поиск в лабиринте, где нет пути

	```
	Введите размерность: 3 3
	Введите матрицу в обычном виде (1 - стенка, 0 - проход)
	0 0 1
	0 1 0
	1 1 0
	Введите стартовую позицию: 0 0
	Введите финишную позицию: 2 2
	
	Реализация массивом:
	Нет пути!
	┏━━┓
	┃__█┃
	┃_█ ┃
	┃██ ┃
	┗━━┛
	
	Реализация списком:
	Нет пути!
	┏━━┓
	┃__█┃
	┃_█ ┃
	┃██ ┃
	┗━━┛
	
	Время реализации массивом: 75 тиков
	Время реализации списком: 39 тиков
	```

2. Поиск в лабиринте с путем

	```
	Введите размерность: 3 3
	Введите матрицу в обычном виде (1 - стенка, 0 - проход)
	0 0 1
	1 0 1
	0 0 0
	Введите стартовую позицию: 0 0
	Введите финишную позицию: 2 2
	
	Реализация массивом:
	0 0
	0 1
	1 1
	2 1
	2 2
	┏━━┓
	┃**█┃
	┃█*█┃
	┃_**┃
	┗━━┛
	
	Реализация списком:
	0 0
	0 1
	1 1
	2 1
	2 2
	┏━━┓
	┃**█┃
	┃█*█┃
	┃ **┃
	┗━━┛
	
	Время реализации массивом: 71 тиков
	Время реализации списком: 17 тиков
	```

## Алгоритм

**Поиск пути в лабиринте происходит алгоритмом поиска в глубину по графу**

```
1. Добавить стартовую клетку в стек
2. Отметить стартовую клетку как посещенную
3. Пока есть непосещенные клетки или не найден выход
	4. Если текущая клетка имеет непосещенных соседей
		5. Перейти к одному из непосещенных соседей
		6. Добавить новую клетку в стек
		7. Отметить клетку как посещенную
	8. Иначе если стек не пуст
		9. Удалить верхний элемент стека 
```

## Сравнение реализций

### Время

|Размерность лабиринта|Реализация списком (тиков)|Реализация массивом (тиков)|Эффективность|
|---|---|---|---|
|50 на 50|87323802|89646777|2%|
|100 на 100|269278104|270988091|0.6%|
|250 на 250|8036865335|8032045540|0.05%|
|500 на 500|150708151285|147360338423|2%|

### Память

|Размерность лабиринта|Реализация списком (байт)|Реализация массивом (байт)|Эффективность|
|---|---|---|---|
|50 на 50|15000|400000|96%|
|100 на 100|60000|400000|85%|
|250 на 250|375000|400000|78%|
|500 на 500|1500000|400000|96%|

### Время дабавления и удаления 1000 элементов

|Реализация списком|Реализация массивом|Эффективность|
|---|---|---|
|448815|46584|863%|

## Контрольные вопросы

1. **Что такое стек?**<br>Структура данных, в которой данные располагаются друг за другом, а доступ есть только к последнему<br><br>
2. **Каким образом и сколько памяти выделяется под хранение стека при
различной его реализации?**<br>В случае реализиции массивом память выделяется сразу на максимальный размер стека. При реализации списком память выделяется отдельно для каждого элемента при добавлении его в стек.<br><br>
3. **Каким образом освобождается память при удалении элемента стека при различной реализации стека?**<br>При реализации массивом, память очищается только после прекращения работы с ним. При реализации списком, память необходимо очищать как после каждого удаления элемента. После завершения работы со стеком память также очищается поэлементно.<br><br>
4. **Что происходит с элементами стека при его просмотре?**<br>При просмотре стека верхний элемент удаляется и указатель передвигается на новый последний.<br><br>
5. **Каким образом эффективнее реализовывать стек? От чего это зависит?**<br>По времени эффективнее использовать массив, а для памяти эффективнее список при небольшом количестве элементов<br><br>

## Вывод

Реализация массивом всегда занимает максимальную память, в отличии от списка, который занимает столько памяти, сколько ему надо в данный момент. Благодаря этому реализация массивом работает быстрее, посколько не тратится время на выделение памяти. Таким образом при работе с большим количеством элементов выгоднее использовать массив, а при небольшом - список.